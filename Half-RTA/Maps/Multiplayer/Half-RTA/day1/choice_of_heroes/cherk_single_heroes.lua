
PATH_TO_CHOISE_OF_HEROES = PATH_TO_DAY1_MODULE.."choice_of_heroes/";

doFile(PATH_TO_CHOISE_OF_HEROES.."common.lua");
sleep(1);

-- —писок случайных героев дл€ выбранных рас
randomHeroList = {
  [PLAYER_1] = {
    { raceId = nil, name = nil, selected = nil, deleted = nil, manual_change = nil, red_icon = nil, blue_icon = nil },
    { raceId = nil, name = nil, selected = nil, deleted = nil, manual_change = nil, red_icon = nil, blue_icon = nil },
    { raceId = nil, name = nil, selected = nil, deleted = nil, manual_change = nil, red_icon = nil, blue_icon = nil },
    { raceId = nil, name = nil, selected = nil, deleted = nil, manual_change = nil, red_icon = nil, blue_icon = nil },
    { raceId = nil, name = nil, selected = nil, deleted = nil, manual_change = nil, red_icon = nil, blue_icon = nil },
    { raceId = nil, name = nil, selected = nil, deleted = nil, manual_change = nil, red_icon = nil, blue_icon = nil },
    { raceId = nil, name = nil, selected = nil, deleted = nil, manual_change = nil, red_icon = nil, blue_icon = nil },
  },
  [PLAYER_2] = {
    { raceId = nil, name = nil, selected = nil, deleted = nil, manual_change = nil, red_icon = nil, blue_icon = nil },
    { raceId = nil, name = nil, selected = nil, deleted = nil, manual_change = nil, red_icon = nil, blue_icon = nil },
    { raceId = nil, name = nil, selected = nil, deleted = nil, manual_change = nil, red_icon = nil, blue_icon = nil },
    { raceId = nil, name = nil, selected = nil, deleted = nil, manual_change = nil, red_icon = nil, blue_icon = nil },
    { raceId = nil, name = nil, selected = nil, deleted = nil, manual_change = nil, red_icon = nil, blue_icon = nil },
    { raceId = nil, name = nil, selected = nil, deleted = nil, manual_change = nil, red_icon = nil, blue_icon = nil },
    { raceId = nil, name = nil, selected = nil, deleted = nil, manual_change = nil, red_icon = nil, blue_icon = nil },
  },
};

-- „ерк по одному герою
function cherkSingleHeroes()
  print "cherkSingleHeroes"
  
--  SetObjectEnabled('red1', nil); SetDisabledObjectMode('red17', DISABLED_BLOCKED);
--  SetObjectEnabled('red2', nil); SetDisabledObjectMode('red18', DISABLED_BLOCKED);
--  SetObjectEnabled('blue1', nil); SetDisabledObjectMode('blue17', DISABLED_BLOCKED);
--  SetObjectEnabled('blue2', nil); SetDisabledObjectMode('blue18', DISABLED_BLOCKED);
  
--  SetObjectPosition('red1', 31, 86);
--  SetObjectPosition('red2', 39, 86);
--  SetObjectPosition('blue1', 31, 88);
--  SetObjectPosition('blue2', 39, 88);

    SetObjectPosition('blue10', 1, 1);

    SetObjectPosition('red1', 42, 26);
    SetObjectPosition('blue1', 42, 18);
    
    SetObjectPosition('blue2', 35, 91);
  
--  SetObjectPosition('red19', 44, 24);
--  SetObjectPosition('red20', 44, 24);
--  SetObjectPosition('blue19', 44, 24);
--  SetObjectPosition('blue20', 44, 24);
  

  
--  SetObjectEnabled('red19', nil); SetDisabledObjectMode('red19', DISABLED_BLOCKED);
--  SetObjectEnabled('red20', nil); SetDisabledObjectMode('red20', DISABLED_BLOCKED);
--  SetObjectEnabled('blue19', nil); SetDisabledObjectMode('blue19', DISABLED_BLOCKED);
--  SetObjectEnabled('blue20', nil); SetDisabledObjectMode('blue20', DISABLED_BLOCKED);
  
  SetObjectPosition(Biara, 35, 87);
  SetObjectPosition(Djovanni, 42, 22);

  removeHeroMovePoints(Djovanni);
  addHeroMovePoints(Biara)

  removeRaceRegionTriggers();

  -- ћен€ем описание портретов всех героев выбранных рас
  changeDescriptionForSelectedRaceHeroIcons();

  -- √енерируем списки случайных героев дл€ обоих игроков
  generateRandomHeroListByPlayerIdAndRaceId(PLAYER_1, SELECTED_RACE_ID_TABLE[1]);
  generateRandomHeroListByPlayerIdAndRaceId(PLAYER_2, SELECTED_RACE_ID_TABLE[2]);

  -- –асставл€ем сгенерированных героев дл€ выбора
  for playerId = 1, length(randomHeroList) do
    local heroList = randomHeroList[playerId];

    for heroIndex = 1, length(heroList) do
      local heroData = heroList[heroIndex];

      if playerId == PLAYER_1 then
        SetObjectPosition(heroData.red_icon, (31 + heroIndex), 85, GROUND);
        SetObjectPosition(heroData.blue_icon, (38 + heroIndex), 23, GROUND);
      else
        SetObjectPosition(heroData.red_icon, (31 + heroIndex), 88, GROUND);
        SetObjectPosition(heroData.blue_icon, (38 + heroIndex), 20, GROUND);
      end;

      Trigger(OBJECT_TOUCH_TRIGGER, heroData.red_icon, 'handleTouchHero');
      Trigger(OBJECT_TOUCH_TRIGGER, heroData.blue_icon, 'handleTouchHero');
    end;
  end;

  changePlayersTurnForChoosingHero();
end;

-- ”даление триггеров с регионов, где находились расы
function removeRaceRegionTriggers()
  print "removeRaceRegionTriggers"

  Trigger( REGION_ENTER_WITHOUT_STOP_TRIGGER, 'pl1_race1', 'noop');
  Trigger( REGION_ENTER_WITHOUT_STOP_TRIGGER, 'pl1_race2', 'noop');
  Trigger( REGION_ENTER_WITHOUT_STOP_TRIGGER, 'pl1_race3', 'noop');
  Trigger( REGION_ENTER_WITHOUT_STOP_TRIGGER, 'pl1_race4', 'noop');
  Trigger( REGION_ENTER_WITHOUT_STOP_TRIGGER, 'pl1_race5', 'noop');
  Trigger( REGION_ENTER_WITHOUT_STOP_TRIGGER, 'pl1_race6', 'noop');
  Trigger( REGION_ENTER_WITHOUT_STOP_TRIGGER, 'pl1_race7', 'noop');
  Trigger( REGION_ENTER_WITHOUT_STOP_TRIGGER, 'pl1_race8', 'noop');
  Trigger( REGION_ENTER_WITHOUT_STOP_TRIGGER, 'pl2_race1', 'noop');
  Trigger( REGION_ENTER_WITHOUT_STOP_TRIGGER, 'pl2_race2', 'noop');
  Trigger( REGION_ENTER_WITHOUT_STOP_TRIGGER, 'pl2_race3', 'noop');
  Trigger( REGION_ENTER_WITHOUT_STOP_TRIGGER, 'pl2_race4', 'noop');
  Trigger( REGION_ENTER_WITHOUT_STOP_TRIGGER, 'pl2_race5', 'noop');
  Trigger( REGION_ENTER_WITHOUT_STOP_TRIGGER, 'pl2_race6', 'noop');
  Trigger( REGION_ENTER_WITHOUT_STOP_TRIGGER, 'pl2_race7', 'noop');
  Trigger( REGION_ENTER_WITHOUT_STOP_TRIGGER, 'pl2_race8', 'noop');
end;

--убираем перегородки
function deleteFlagsCrystal()

    SetObjectPosition('blue10', 42, 26);
    SetObjectPosition('red1', 1, 1);
    SetObjectPosition('blue1', 1, 1);
    SetObjectPosition('blue2', 1, 1);

end;

-- ћен€ем им€ и описание дл€ всех героев переданных рас
function changeDescriptionForSelectedRaceHeroIcons()
  print "changeDescriptionForSelectedRaceHeroIcons"

  -- »змен€ем название и описание портретов всех героев выбранных рас на карте
  for raceIndex, raceId in SELECTED_RACE_ID_TABLE do
    local currentRaceHeroList = HEROES_BY_RACE[raceId];

    for heroIndex, heroData in currentRaceHeroList do
      local playerList = { PLAYER_1, PLAYER_2 };

      for playerIndex, playerId in playerList do
        for iconsIndex = 1, length(heroData[playerId]) do
          local icons = heroData[playerId][iconsIndex];

          SetObjectEnabled(icons.red_icon, nil);
          OverrideObjectTooltipNameAndDescription(icons.red_icon, PATH_TO_HERO_NAMES..heroData.txt, heroData.dsc);
          SetObjectEnabled(icons.blue_icon, nil);
          OverrideObjectTooltipNameAndDescription(icons.blue_icon, PATH_TO_HERO_NAMES..heroData.txt, heroData.dsc);
        end;
      end;
    end;
  end;
end;

-- √енераци€ 7 случайных героев переданной расы дл€ выбранного игрока
function generateRandomHeroListByPlayerIdAndRaceId(playerId, raceId)
  print "generateRandomHeroListByPlayerIdAndRaceId"

  for generateIndex = 1, 7 do
    local currentRaceHeroList = HEROES_BY_RACE[raceId];
    local randomHeroIndex, randomHeroName, isHeroExist;

    repeat
      randomHeroIndex = random(length(currentRaceHeroList)) + 1;
      randomHeroName = currentRaceHeroList[randomHeroIndex].name;

      isHeroExist = getHasHeroInHeroRandomList(playerId, randomHeroName);
    until not isHeroExist;

    randomHeroList[playerId][generateIndex] = {
      name = randomHeroName,
      raceId = raceId,
      red_icon = currentRaceHeroList[randomHeroIndex][playerId][1].red_icon,
      blue_icon = currentRaceHeroList[randomHeroIndex][playerId][1].blue_icon,
    };
  end;
end;

-- ѕолучение признака, есть ли такой герой в списке дл€ выбора у определенного игрока
function getHasHeroInHeroRandomList(playerId, heroName)
  print "getHasHeroInHeroRandomList"

  local count = 0;
  local randomHeroes = randomHeroList[playerId]

  for indexHero = 1, length(randomHeroes) do
    if (randomHeroes[indexHero].name == heroName) then
      count = count + 1;
    end;
  end;

  return count > 0;
end;

-- ќбработчик касани€ героев дл€ выбора
function handleTouchHero(triggerPlayerHero, triggeredHeroIconName)
  print "handleTouchHero"

  -- игрок, которому принадлежит этот герой
  local player, heroName = getRelatedPlayerAndHeroNameByHeroIconName(triggeredHeroIconName);

  local triggerPlayer = GetPlayerFilter(GetObjectOwner(triggerPlayerHero));
  local action = getCurrentTurnAction();
  local question = action == TURN_ACTIONS.CHOOSING and "question_add_hero.txt" or "question_delete_hero.txt";

  QuestionBoxForPlayers(triggerPlayer, PATH_TO_DAY1_MESSAGES..question, "handlerAddOrDeleteHero('"..player.."', '"..heroName.."')", 'noop');
end;

-- ѕолучение игрока, которому принадлежит выбранный герой
function getRelatedPlayerAndHeroNameByHeroIconName(heroIconName)
  print "getRelatedPlayerAndHeroNameByHeroIconName"

  for playerId = 1, length(randomHeroList) do
    local heroList = randomHeroList[playerId];

    for heroIndex = 1, length(heroList) do
      local heroData = heroList[heroIndex];

      if (heroData.red_icon == heroIconName or heroData.blue_icon == heroIconName) then
        return playerId, heroData.name;
      end;
    end;
  end;
end;

-- ѕризнак, что идет первым: выбор или удаление: 0 - сначала добавл€ем, 1 - сначала удал€ем
RANDOM_CHOOSE_FIRST_FLAG = 1;--random(2);

-- ѕеречисление типов хода при черке героев: 0 - ¬ычеркиваем, 1 - ƒобавл€ем
TURN_ACTIONS = {
  CHOOSING = 1,
  DELETING = 0,
};

-- ѕолучение типа действи€ текущего хода:
function getCurrentTurnAction()
  print "getCurrentTurnAction"

  -- —оотношение хода геро€ к типу действи€ при черке
  local mapFlagToTurnAction = {
    [0] = { TURN_ACTIONS.CHOOSING, TURN_ACTIONS.CHOOSING, TURN_ACTIONS.DELETING, TURN_ACTIONS.DELETING, TURN_ACTIONS.CHOOSING, TURN_ACTIONS.CHOOSING, TURN_ACTIONS.DELETING, TURN_ACTIONS.DELETING, TURN_ACTIONS.CHOOSING, TURN_ACTIONS.CHOOSING, TURN_ACTIONS.DELETING, TURN_ACTIONS.DELETING },
    [1] = { TURN_ACTIONS.DELETING, TURN_ACTIONS.DELETING, TURN_ACTIONS.CHOOSING, TURN_ACTIONS.CHOOSING, TURN_ACTIONS.DELETING, TURN_ACTIONS.DELETING, TURN_ACTIONS.CHOOSING, TURN_ACTIONS.CHOOSING, TURN_ACTIONS.DELETING, TURN_ACTIONS.DELETING, TURN_ACTIONS.CHOOSING, TURN_ACTIONS.CHOOSING },
  };
  local turn = getHeroTurn();

  return mapFlagToTurnAction[RANDOM_CHOOSE_FIRST_FLAG][turn + 1];
end;

-- ѕолучение номера текущего хода
function getHeroTurn()
  print "getHeroTurn"

  local count = 0;

  -- —читаем всех героев, которые были добавлены или удалены игроками
  for playerId = 1, length(randomHeroList) do
    local heroList = randomHeroList[playerId];

    for heroIndex = 1, length(heroList) do
      local heroData = heroList[heroIndex];

      if (heroData.manual_change) then
        count = count + 1;
      end;
    end;
  end;

  return count;
end;

-- ќбработчик удалени€ или добавлени€ геро€
function handlerAddOrDeleteHero(playerId, heroName)
  print "handlerAddOrDeleteHero"

  -- ѕреобразование строки к числу
  local playerId = playerId + 0;

  local action = getCurrentTurnAction();
  if action == TURN_ACTIONS.CHOOSING then
    addHeroForPlayer(playerId, heroName, true);
  else
    hideHeroToUnderground(playerId, heroName, true);
  end;

  checkOnSelectMaximumHeroes();
  changePlayersTurnForChoosingHero();
end;

-- ѕроставление герою признака выбранного
function addHeroForPlayer(playerId, heroName, manual)
  print "addHeroForPlayer"

  for heroIndex = 1, length(randomHeroList[playerId]) do
    local heroData = randomHeroList[playerId][heroIndex];

    if (heroData.name == heroName) then
      heroData.selected = true;
      heroData.manual_change = manual;

      for indexDictHero = 1, length(HEROES_BY_RACE[heroData.raceId]) do
        local dictHero = HEROES_BY_RACE[heroData.raceId][indexDictHero];

        if (dictHero.name == heroName) then
          local icons = dictHero[playerId][1];

          if playerId == PLAYER_1 then
            SetObjectPosition(icons.red_icon, (31 + heroIndex), 84, GROUND);
            SetObjectPosition(icons.blue_icon, (38 + heroIndex), 24, GROUND);
          else
            SetObjectPosition(icons.red_icon, (31 + heroIndex), 89, GROUND);
            SetObjectPosition(icons.blue_icon, (38 + heroIndex), 19, GROUND);
          end;

          Trigger(OBJECT_TOUCH_TRIGGER, icons.red_icon, 'noop');
          Trigger(OBJECT_TOUCH_TRIGGER, icons.blue_icon, 'noop');
        end;
      end;
    end;
  end;
end;

-- —крытие иконки геро€ в подземелье
function hideHeroToUnderground(playerId, heroName, manual)
  print "hideHeroToUnderground"

  for heroIndex = 1, length(randomHeroList[playerId]) do
    local heroData = randomHeroList[playerId][heroIndex];

    if (heroData.name == heroName) then
      heroData.deleted = true;
      heroData.manual_change = manual;

      SetObjectPosition(heroData.red_icon, 1, 1, UNDERGROUND);
      SetObjectPosition(heroData.blue_icon, 1, 1, UNDERGROUND);
    end;
  end;
  -- TODO
end;

-- ѕроверка на максимум выбранных героев на каждой стороне
function checkOnSelectMaximumHeroes()
  print "checkOnSelectMaximumHeroes"

  for playerId = 1, length(randomHeroList) do
    local heroList = randomHeroList[playerId];
    local countDeletedHero = 0;
    local countSelectedHero = 0;

    for heroIndex = 1, length(heroList) do
      local heroData = heroList[heroIndex];

      if heroData.deleted then
        countDeletedHero = countDeletedHero + 1;
      end;

      if heroData.selected then
        countSelectedHero = countSelectedHero + 1;
      end;
    end;

    -- ≈сли вычеркнуто 3 геро€, добавл€ем всех оставшихс€ героев в набор
    if countDeletedHero > 2 then
      for heroIndex = 1, length(heroList) do
        local heroData = heroList[heroIndex];

        if (not heroData.deleted and not heroData.selected) then
          addHeroForPlayer(playerId, heroData.name)
        end;
      end;
    end;

    -- ≈сли добавлено 3 геро€, удал€ем всех оставшихс€ героев в набор
    if countSelectedHero > 3 then
      for heroIndex = 1, length(heroList) do
        local heroData = heroList[heroIndex];

        if (not heroData.deleted and not heroData.selected) then
          hideHeroToUnderground(playerId, heroData.name);
        end;
      end;
    end;
  end;
end;

-- ќбработчик изменени€
function changePlayersTurnForChoosingHero()
  print "changePlayersTurnForChoosingHero"

  -- Ќомер текущего хода черка героев
  local turn = getHeroTurn();
  local turnAction = getCurrentTurnAction();
  local countSideFullfied = getCountSideFullfied();
  local message = turnAction == TURN_ACTIONS.CHOOSING and "include_single_hero.txt" or "exclude_single_hero.txt";

  -- ≈сли 2 списка заполнены - заканчиваем черк
  if countSideFullfied == 2 then
    setResultHeroes();
  else
    -- „етные ходы выбирает красный, Ќечетные - синий
    if mod(turn, 2) == 0 then
      removeHeroMovePoints(Djovanni);
      addHeroMovePoints(Biara);
      ShowFlyingSign(PATH_TO_DAY1_MESSAGES..message, Biara, PLAYER_1, 7.0);
    else
      removeHeroMovePoints(Biara);
      addHeroMovePoints(Djovanni);
      ShowFlyingSign(PATH_TO_DAY1_MESSAGES..message, Djovanni, PLAYER_2, 7.0);
    end;
  end;
end;

-- ѕризнак заполнена ли одна из сторон или нет: 0 - Ќе заполнены, 1 - «аполнена
function getCountSideFullfied()
  print "getCountSideFullfied"

  local countSide = 0;

  for playerId = 1, length(randomHeroList) do
    local heroList = randomHeroList[playerId];

    local countSelectedHero = 0;

    for heroIndex = 1, length(heroList) do
      local heroData = heroList[heroIndex];

      if heroData.selected then
        countSelectedHero = countSelectedHero + 1;
      end;
    end;

    if countSelectedHero == 4 then
      countSide = countSide + 1;
    end;
  end;

  return countSide;
end;

-- ”даление оставшихс€ групп героев
function deleteResultHeroIcons()
  print "deleteResultHeroIcons"

  -- –асставл€ем сгенерированных героев дл€ выбора
  for playerId = 1, length(randomHeroList) do
    local heroList = randomHeroList[playerId];

    for heroIndex = 1, length(heroList) do
      local heroData = heroList[heroIndex];

      hideHeroToUnderground(playerId, heroData.name);
      hideHeroToUnderground(playerId, heroData.name);
    end;
  end;
end;

-- ѕолучение конечного списка героев дл€ обоих игроков
function setResultHeroes()
  print "setResultHeroes"

  sleep(1);

  deleteResultHeroIcons();

  for playerId = 1, length(randomHeroList) do
    local heroList = randomHeroList[playerId]
    -- —писок выбранных героев дл€ рандомного выбора
    local selectedHero = {};

    for heroIndex = 1, length(heroList) do
      local heroData = heroList[heroIndex];

      if heroData.selected then
        local pushedIndex = length(selectedHero) + 1;

        selectedHero[pushedIndex] = heroData.name;
      end;
    end;

    -- «аписываем список героев, которые будем показывать оппоненту
    RESULT_HERO_LIST[playerId].choised_heroes = selectedHero;
    -- «аписываем расу игрока
    RESULT_HERO_LIST[playerId].raceId = heroList[1].raceId;
  end;

  -- «аполн€ем итоговый список 2 случайными выбранными геро€ми и 1 рандомным
  setRandomHeroFromHeroList();
  
  deleteFlagsCrystal()
  
end;




cherkSingleHeroes();